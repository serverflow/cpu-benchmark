# SFBench — CPU Benchmark

```
   _____ ______ ____                  _     
  / ____|  ____|  _ \                | |    
 | (___ | |__  | |_) | ___ _ __   ___| |__  
  \___ \|  __| |  _ < / _ \ '_ \ / __| '_ \ 
  ____) | |    | |_) |  __/ | | | (__| | | |
 |_____/|_|    |____/ \___|_| |_|\___|_| |_|
```

SFBench — кроссплатформенный консольный бенчмарк CPU. Мы строили его вокруг двух вещей: 
честного сравнения разных архитектур и понятного сравнения разных типов данных. 
Именно поэтому у нас есть два основных теста — `--mode=compute` и `--precision=all`. 
Они же публикуются на bench.serverflow.ru.

## Минимальные требования к процессору (чтобы гарантированно запускалось)

**x86‑64 (Windows/Linux):**
- Обязательны **AVX2** и **FMA3**.
- ОС должна поддерживать **AVX/XSAVE** (иначе инструкции будут запрещены).

**ARM64 (macOS/Linux/Windows ARM):**
- Обязателен **ARMv8‑A с NEON**.

Если этих требований нет (например, старые Intel Sandy Bridge с AVX, но без FMA3),
приложение может завершаться с *illegal instruction*.

## Быстрый старт

```bash
# Windows
cpu_benchmark.exe 
cpu_benchmark.exe --mode=...

# Linux/macOS
./cpu_benchmark 
./cpu_benchmark --mode=...
```

Запуск **без аргументов** включает «полный запуск» (с подтверждением) и выполняет:
1) прогрев CPU, 2) `--mode=compute`, 3) `--precision=all`.

> Важно: полный запуск не включает mem/stencil/matmul/cache — только два ключевых теста.

---

## Главные тесты (те, что попадают на сайт)

### `--mode=compute` — кросс‑архитектурный пик CPU
**Что измеряет:** чистую вычислительную мощность, сравнимую между x86 и ARM.

**Как работает (по коду):**
- Основа — **scalar FP64 FMA** (без SIMD), авто‑векторизация отключена.
- 8 независимых цепочек FMA ⇒ **16 FLOPs на итерацию**.
- Измерение по времени: фиксированные **10 секунд** на ST и MT.
- Прогрев перед тестом: **3 секунды** (можно отключить `--no-warmup`).
- Для гибридных CPU стараемся закрепить ST на P‑ядре; MT распределяем по ядрам с приоритетом P‑ядер.
- SIMD‑результаты (FP32) выводятся **только для справки** и **не участвуют** в скоринге.

**Скоринг:**
```
Score = GFLOPS * 100
Overall = 0.3 * ST + 0.7 * MT
```

**Почему так:**
- SIMD‑ширина и набор инструкций сильно различаются между архитектурами.
- Scalar FP64 даёт честную базу «ядро‑к‑ядру», без бонусов за ширину вектора.
- Фиксированное время снижает разброс и упрощает сравнение на разных системах.

**Полезные заметки:**
- `--precision` и `--size` здесь не влияют — тест всегда FP64 scalar.
- `--threads` и `--socket` влияют на MT.
- `SFBENCH_NO_SIMD=1` отключает SIMD‑справку.

---

### `--precision=all` — сравнение типов данных (compute‑bound)
**Что измеряет:** относительную вычислительную производительность разных форматов.

**Как работает (по коду):**
- Это **compute‑bound тест**: данные подогнаны под **L2 ≈ 256 KB**.
- Используются два массива A и B (половина L2 на каждый), 
  а результаты накапливаются в регистрах.
- Базовая операция для float/double: `acc += A[i] * B[i] + 0.5` (2 FLOPs на элемент).
- Каждая точность запускается отдельно, с единым планом прогрева и замеров.
- Время измерения нормируется (см. `--time`):
  - прогрев ~ `min_time/20` (0.1–0.5с)
  - тест ~ `min_time/10` (0.2–1.0с)
- Итерации калибруются до устойчивого размера чанка (цель ~2мс на чанк).

**Тестируемые типы:**
- **FP64** — double
- **FP32** — float
- **FP16** — *native* (ARM NEON FP16 / AVX‑512 FP16) или *emulated*
- **INT8** — целые, отчёт в **GOPS**
- **FP4** — эмуляция 4‑битного float (2 значения на байт)

**Почему так:**
- Сравнивать типы «в лоб» через память нечестно — всё упирается в bandwidth.
- Фиксация рабочей области в L2 делает тест **про вычисления**, а не про RAM.
- Единая форма ядра даёт сопоставимые результаты для FP64/FP32/FP16/INT8/FP4.

**Важные нюансы:**
- `--size` в `--precision=all` **не влияет на вычисления** (размер фиксирован под L2),
  но участвует в проверке памяти и метаданных отправки.
- FP16 будет *native* только если **и CPU поддерживает**, и бинарник собран с FP16.
  Для ARM рекомендуем сборку с `-march=armv8.2-a+fp16+simd`.

---

## Остальные режимы

### `--mode=mem` — пропускная способность памяти
AXPY‑подобная операция: `C = α·A + β·B` по 3D массиву.
- **3 FLOPs на элемент**, измеряется GFLOPS и GB/s.
- По умолчанию включён авто‑размер (см. ниже).

### `--mode=stencil` — 7‑точечный stencil
Сумма 6 соседей + умножения коэффициентами.
- **8 FLOPs на внутреннюю ячейку**.
- Метрика: GFLOPS + MLUP/s.

### `--mode=matmul3d` — батч умножение матриц
Z слоёв матриц NxN, классический i‑j‑k.
- **2·N³·Z FLOPs**.
- Полезно для оценки кэшей и линейной алгебры.

### `--mode=cache` — уровни кэша
Автоматически подбирает объёмы под L1/L2/L3 и RAM‑bound.
- Тест — AXPY‑ядро.
- `--precision` и `--size` здесь не используются.

---

## Параметры командной строки

| Параметр | Значения | По умолчанию | Примечание |
|---|---|---|---|
| `--mode` | compute, mem, stencil, matmul3d, cache | mem | compute/cache используют собственные сценарии |
| `--precision` | float, double, fp64, fp16, int8, fp4, all | float | `all` запускает сравнение типов |
| `--threads` | 0…N | 0 (auto) | 0 = все логические ядра |
| `--time` | секунды | 3.0 | минимум времени на измерение (кроме compute) |
| `--repeats` | 1…N | 5 | число повторов (кроме compute) |
| `--size` | NxNxN | 128x128x128 | переопределяет авто‑размер |
| `--auto-size` / `--no-auto-size` | — | auto-size включён | подбор размера по RAM |
| `--socket` | 0…N | -1 (все) | фиксирует выполнение на одном сокете |
| `--output` | text, json, csv | text | формат вывода |
| `--no-color` | — | off | отключить цвета в таблице precision |
| `--force-scalar` | — | off | отключить SIMD‑ядра там, где они есть |
| `--quiet` | — | off | скрыть прогресс‑лог |
| `--no-warmup` | — | off | пропустить прогрев |
| `--high-priority` | — | off | повышенный приоритет (в compute) |
| `--version` | — | — | версия и компилятор |
| `--help` | — | — | справка |

---

## Авто‑размер и память
- По умолчанию размер **подбирается автоматически** из доступной RAM.
- Используется **50% safety‑margin**, максимум — куб **500×500×500**.
- Проверка памяти проводится перед запуском (для `precision=all` — по FP64).

---

## Отправка результатов
- Отправка предлагается **только после «чистого» запуска**.
- «Чистый» — без кастомных `--threads/--time/--repeats/--size`, без `--force-scalar` и `--no-warmup`.
- Для публикации на сайте принимаются **compute** и **precision=all**.

---

## Сборка из исходников

### Общие требования
- **CMake** ≥ 3.14
- **C++17 компилятор**
  - Windows: MSVC 2019+ (рекомендуем Visual Studio 2022)
  - Linux: GCC 9+ или Clang 10+
  - macOS: Apple Clang (из Xcode Command Line Tools)
- **Git** нужен только если вы собираете тесты (`BUILD_TESTS=ON`)

### Windows
**Что установить:**
1. **Visual Studio 2022 Community** (или Build Tools)  
   В установщике выберите **“Разработка классических приложений на C++”** и убедитесь, что стоят:
   - MSVC (C++ Build Tools)
   - Windows 10/11 SDK
   - CMake Tools for Windows
2. (Опционально) **Git**, если нужны тесты

**Сборка (PowerShell):**
```powershell
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTS=OFF
cmake --build build --config Release
.\build\Release\cpu_benchmark.exe
```

### Linux
**Ubuntu / Debian**
```bash
sudo apt update
sudo apt install -y build-essential cmake git
```

**Fedora / RHEL / CentOS**
```bash
sudo dnf install -y gcc-c++ make cmake git
```

**Arch Linux**
```bash
sudo pacman -S --needed base-devel cmake git
```

**Сборка:**
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTS=OFF
cmake --build build -j$(nproc)
./build/cpu_benchmark
```

### macOS
**Что установить:**
1. **Xcode Command Line Tools**  
   ```bash
   xcode-select --install
   ```
2. **CMake** (через Homebrew)
   ```bash
   brew install cmake
   ```
3. (Опционально) **Git**, если нужны тесты

**Сборка:**
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTS=OFF
cmake --build build -j$(sysctl -n hw.ncpu)
./build/cpu_benchmark
```

> Для Apple Silicon проект собирается как ARM64 и использует NEON; для нативного FP16 важна сборка с поддержкой `-march=armv8.2-a+fp16+simd` (у нас она включена в CMake).

Если нужны тесты, уберите `-DBUILD_TESTS=OFF` и убедитесь, что Git доступен (FetchContent подтянет RapidCheck).

---

## Опции CMake

| Опция | По умолчанию | Описание |
|---|---|---|
| `BUILD_TESTS` | ON | Собирать тесты (RapidCheck) |
| `ENABLE_NATIVE_ARCH` | ON | `-march=native` для dev‑сборок |
| `BUILD_PORTABLE` | OFF | Портативный бинарник со статической линковкой |
| `USE_RELEASE_BUILD_CONFIG` | OFF | Подключить модуль оптимизаций для релиза |

---

## SIMD и поддержка архитектур
- **x86‑64:** SSE2, SSE4.2, AVX, AVX2, AVX‑512
- **ARM64:** NEON, NEON FP16
- Выбор SIMD выполняется **в рантайме**.
